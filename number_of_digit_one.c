/**
 * Given an integer n, count the total number of digit 1 appearing in all
 * non-negative integers less than or equal to n.
 *
 * Example:
 *
 * Input: 13
 * Output: 6
 * Explanation: Digit 1 occurred in the following numbers: 1, 10, 11, 12, 13.
 *
 * 给定一个整数n,统计小于等于n的所有整数中数字1出现的次数.
 * 自己想了半天没啥太好的思路,直接看了LeetCode上的答案,一道找规律的题目.
 * 大致思路如下:
 * 1. 对于一个整数n,分别统计每一位(个位,十位,百位,千位...)上面数字1出现的次数.
 * 2. 接下来的问题是找到每一位上数字1出现的规律;
 * 3. 对于个位来说,1,11,21,31,41,51,...,91,不难发现,每隔10位数出现一次;对应的
 *    计算公式就是: n/10 + (n%10 != 0).既然每隔10个数出现一次,那自然除以10就
 *    得到了出现的次数,另外要注意个位本身是1的情况,例如21和22这两个数,21的话,
 *    结果应该是3,而22的结果是2.
 * 3. 对于十位来说,结论没那么明显,先看下下面的例子:
 *    10    110   210   310
 *    11    111   211   311
 *    12    112   212   312
 *    13    113   213   313
 *    14    114   214   314
 *    15    115   215   315
 *    16    116   216   316
 *    17    117   217   317
 *    18    118   218   318
 *    19    119   219   319
 *    不难发现十位上的1每隔100出现10次,但还要考虑一点特殊情况:小于100的数如何计
 *    算?例如100,十位上1出现的次数是10次,但是135呢?从1到100的十位上出现了10次,
 *    从100到135的十位上也出现了10次.也就是说我们需要判断整数n除以100的余数和10
 *    的关系,例如115,除以100的余数是15,那么在十位上出现的数字1的次数要加上6次,为
 *    什么是6次不是5次,因为10~15是6个数(好像有点废话).计算公式:
 *    (n/100)*10 + min(max(n%100 - 10 + 1, 0), 10).
 *    这里之所以出现min和max是考虑边界情况,例如105除以100的余数是5,5-10是负数,所
 *    以用max限定最小是0,外层的min是因为余数中最多只有10次;
 * 4. 对于百位的情况,也是类似,最后总结计算每一位上数字1出现的次数的通式为:
 *           (n/m)*m/10 + min(max(n%m - m/10 + 1, 0), m/10)
 *    对于个位而言m=10,对十位位而言m=100,对百位而言m=1000.以此类推.
 */
class Solution {
public:
  int countDigitOne(int n) {
    int ans = 0;

    for (long i = 1; i <= n; i *= 10) {
      /**
       * 这里用i乘以10,要注意溢出问题,令divider为long类型,
       * 另外min,max要求类型一致.另外此题返回类型为int,若
       * int是32位整数的话,输入n过大(比如INT_MAX),实际的
       * 结果是超出INT_MAX的范围的.
       */
      long divider = i * 10;
      ans += (n / divider) * i + min(max(n % divider - i + 1, 0L), i);
    }

    return ans;
  }
};